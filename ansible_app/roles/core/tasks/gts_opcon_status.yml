---
############################################################
# Mismatch
############################################################
- name: Any mismatched state?
  gtsopcon: command="gtsstatus -m" env_number="{{env_number}}"
  register: mismatch_result
  changed_when: False
  # Keep checking 10 times, with 10 seconds intervals until either
  # result count is 0.
  # If result count is not 0, which means some processes are listed
  # then the process can only be Perflogger, or NewsService
  until: "mismatch_result.stdout_lines|gtsOpconResultCount == 0"
  retries: 10
  delay: 1
  ignore_errors: True

#- debug: msg="Line count is {{gtsstatus_result.stdout_lines|gtsOpconResultCount}}"
# - debug: msg="{{gtsstatus_result.stdout_lines|gtsOpconCutFluff}}"
#   when: gtsstatus_result|failed

# At this point, gtsstatus -m has completed
# We would only check each process listed if the Opcon count is not 0
- name: One or more processes are not in their expected state
  fail: msg="One or more processes are not in their expected state"
  #when: "'PerformanceLogger' not in item and 'NewsService' not in item and gtsstatus_result.stdout_lines|gtsOpconResultCount > 0"
  when: ('PerformanceLogger' not in item) and 
        ('NewsService' not in item) and 
        (mismatch_result|failed)
  with_items: "{{mismatch_result.stdout_lines|gtsOpconCutFluff}}"
##############################################################

############################################################
# Down -- Process are only verified 'down' if
# 1. No mismatch is found -- Since mismatch is the first to run,
# any failure would've stopped the playbook from getting here.
# 2. The word 'DOWN' is in stdout. This means the processes
# that are expected to be down, is down. Any runnning process
# is irrelevant, since they are expected to be running.
# i.e. jboss, scheduler, SystemMonitor
# 3. No line containing -- 'No SystemMonitor'
############################################################
- name: All process down?
  gtsopcon: command="gtsstatus" env_number="{{env_number}}"
  register: down_result
  changed_when: False
  until: "'SHUTDWN' not in down_result.stdout"
  retries: 10
  delay: 2
  ignore_errors: True
  when: process_state == 'down'

# - name: Pausing 5 sec to give processes time to come down
#   pause: 5

- name: Processes are not in down state
  fail: msg="One or more processes are not in down state"
  when: (process_state == 'down') and 
        ('No SystemMonitor' in down_result.stdout) and
        ('DOWN' not in down_result.stdout|gtsOpconCutFluff)

##############################################################
############################################################
# Up -- Process are only verified 'up' if
# 1. No mismatch is found -- Since mismatch is the first to run,
# any failure would've stopped the playbook from getting here.
# 2. The word 'RUNNING' is in stdout. This means the processes
# that are expected to be running, is running. Any down process
# is irrelevant, since they are expected to be down
############################################################
- name: All Process up?
  gtsopcon: command="gtsstatus" env_number="{{env_number}}"
  register: up_result
  changed_when: False
  until: ('INITMON' not in up_result.stdout) and
          ('W_SYNC' not in up_result.stdout)
  retries: 10
  delay: 2
  ignore_errors: True
  when: process_state == 'down'

# - name: Pausing 5 sec to give processes time to come down
#   pause: 5

# At this point, gtsstatus -m has completed
# We would only check each process listed if the Opcon count is not 0
- name: Processes are not up!
  fail: msg="One or more processes are not up!"
  when: (process_state == 'up') and 
        ('No SystemMonitor' in up_result.stdout) and
        ('RUNNING' not in up_result.stdout|gtsOpconCutFluff)
        
##############################################################


